# libtool

libtool 封装了不同操作系统不同平台下编译链接C代码生成动态库的差异。
通过libtool，我们可以统一的方式生成特定平台下的库文件。

## libtool的安装

CentOS下，比较简单的libtool安装方式是通过yum install进行安装。
```shell
yum install libtool
```

## 使用libtool进行编译

假设当前目录下有一个**foo.c**文件，使用libtool对foo.c进行编译。
```shell
libtool --mode=compile gcc -g -O -c foo.c
# 输出内容:
#   mkdir .libs
#   gcc -g -O -c foo.c  -fPIC -DPIC -o .libs/foo.o
#   gcc -g -O -c foo.c -o foo.o >/dev/null 2>&1

# 最后一行的标准输出和错误输出的重定位是为了不让警告和错误信息出现两次。
# 可以通过如下方式 不进行输出的重定向
# libtool --mode=compile gcc -no-suppress -g -O -c foo.c
```

在同时支持静态库和动态库的系统下，相当于在当前目录下编译成.o文件，
同时生成.libs目录，并在.libs目录下以PIC(position independent code)的方式
编译生成可链接成动态库的.o文件。另外，还会在当前目录下生成foo.lo文本文件，
用于描述生成.o文件的情况。libtool在链接阶段会以.lo文件作为输入来定位依赖的.o文件。另外，还会在当前目录下生成foo

.lo文件的文本内容如下
```
# foo.lo - a libtool object file
# Generated by ltmain.sh (GNU libtool) 2.4.6
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# Name of the PIC object.
pic_object='.libs/foo.o'

# Name of the non-PIC object.
non_pic_object='foo.o'
```

pic_object表示可用于链接成动态库的.o文件的路径。
non_pic_object表示可用于链接成静态库的.o文件的路径。
具体区别在于是否为PIC代码。


## 使用libtool进行链接

链接成静态库，通常是使用ar程序对.o文件进行打包。 
然后使用ranlib在.a文件中添加索引，从而使得其他程序
在链接该.a文件时更快。实际上ar的s参数与调用ranlib等同。

```shell
ar cru libfoo.a foo.o
# 参数c 表示创建库文件(.a文件)
# 参数r 表示将foo.o插入到.a文件中
# 参数u 表示如果.a文件中已经有重名的.o，只插入更新的。

ranlib libfoo.a
# 在.a文件中添加索引
```

使用libtool链接成静态库和动态库，假设foo.c调用了数学库中的函数，需要链接libm.a。
```shell
libtool --mode=link gcc -g -O -o libfoo.la foo.lo -rpath /usr/local/lib -lm
# 输出内容:
#   rm -fr  .libs/libfoo.a .libs/libfoo.la
#   ld -Bshareable -o .libs/libfoo.so.0.0 .libs/foo.o -lm
#   ar cru .libs/libfoo.a foo.o
#   ranlib .libs/libfoo.a
#   creating libfoo.la
#   (cd .libs && rm -f libfoo.la && ln -s ../libhello.la libhello.la)
```

若要libtool链接生成动态库，通过-rpath指定动态库的安装目录。
libtool会在.libs目录下链接生成静态库.a和动态库.so文件。
并在当前目录下生成.la文件，在.libs目录下创建.la文件的软链接。

.la文件用于记录动态库的安装路径**-rpath**和依赖信息如**-lm**。

## 使用libtool链接成可执行文件


